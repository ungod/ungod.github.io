---
title: ''
---
#### 原理说明

Mass的避障算法相对比较简单，概括来说就是遍历附近Agent和非闪避Obstacle（一般就是地图障碍物和玩家），算出一个避障的力（单位速度方向）来实现，这个力分为远离力`SeparationForce`，避障力`AvoidForce`和障碍力法线`ForcedNormal`。可以查看`UMassMovingAvoidanceProcessor::Execute`代码来看到三者的计算方法。

对于Agent的闪避，会计算远离力`SeparationForce`，闪避力`AvoidForce`。

**远离力**只会在两Agent的圆心距离大于两Agent的半径+`MovingAvoidanceParams.ObstacleSeparationDistance`参数的情况下才会计算并使用，它其实就是其他Agent位置减去自身Agent位置作为速度矢量，即`AgentLocation - Collider.Location`。代码如下：

`//其他Agent相对方向作为远离力方向`

`FVector RelPos = AgentLocation - Collider.Location;`

`RelPos.Z = 0.; // we assume we work on a flat plane for now`

`const FVector RelVel = DesVel - Collider.Velocity;`

`const FVector::FReal ConDist = RelPos.Size();`

`const FVector ConNorm = ConDist > 0. ? RelPos / ConDist : FVector::ForwardVector;`

`FVector SeparationNormal = ConNorm;`

`const FVector::FReal StandingScaling = Collider.bIsMoving ? 1. : MovingAvoidanceParams.StandingObstacleAvoidanceScale; // Care less about standing agents so that we can push through standing crowd.`

`// 计算PenSep表示越接近其他Agent，力越大`

`// 若PenSep为0，即超过ObstacleSeparationDistance配置值，SeparationForce为0`

`const FVector::FReal PenSep = (SeparationAgentRadius + Collider.Radius + MovingAvoidanceParams.ObstacleSeparationDistance) - ConDist;`

`const FVector::FReal SeparationMag = FMath::Square(FMath::Clamp(PenSep / MovingAvoidanceParams.ObstacleSeparationDistance, 0., 1.));`

`const FVector SepForce = SeparationNormal * MovingAvoidanceParams.ObstacleSeparationStiffness;`

`const FVector SeparationForce = SepForce SeparationMag StandingScaling;`



测试
